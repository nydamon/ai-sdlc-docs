#!/usr/bin/env node

/**
 * REAL AI-Powered Test Generator for AI-SDLC
 * Implements actual OpenAI API integration for test generation
 */

// Load environment variables
require('dotenv').config();

const fs = require('fs');
const path = require('path');
const https = require('https');

class RealAITestGenerator {
  constructor() {
    this.openaiApiKey = process.env.OPENAI_API_KEY;
    this.projectRoot = process.cwd();

    if (!this.openaiApiKey || this.openaiApiKey.length < 20) {
      console.warn('⚠️  WARNING: No valid OpenAI API key found');
      console.warn('   Set OPENAI_API_KEY in .env file');
      console.warn('   Falling back to template generation');
      this.useTemplateMode = true;
    } else {
      console.log('✅ OpenAI API key configured - using real AI generation');
      this.useTemplateMode = false;
    }
  }

  /**
   * Generate tests using real OpenAI API
   */
  async generateRealAITests(sourceCode, filePath, testType = 'unit') {
    if (this.useTemplateMode) {
      return this.generateTemplateTests(sourceCode, filePath, testType);
    }

    try {
      const prompt = this.buildAIPrompt(sourceCode, filePath, testType);
      const response = await this.callOpenAI(prompt);

      return this.processAIResponse(response, filePath, testType);
    } catch (error) {
      console.error('❌ OpenAI API failed:', error.message);
      console.warn('🔄 Falling back to template generation');
      return this.generateTemplateTests(sourceCode, filePath, testType);
    }
  }

  /**
   * Build AI prompt for test generation
   */
  buildAIPrompt(sourceCode, filePath, testType) {
    const framework = this.detectFramework(sourceCode);

    return `You are an expert test generator for ${framework} applications. Generate comprehensive ${testType} tests for the following code.

REQUIREMENTS:
- Generate complete, runnable tests
- Include edge cases and error handling
- Use appropriate testing frameworks (Jest for JS/TS, PHPUnit for PHP)
- Follow testing best practices
- Include setup and teardown as needed
- Test all public methods/functions
- Include mock data and assertions

CODE TO TEST:
File: ${filePath}
${sourceCode}

CONTEXT:
- This is for a credit repair application (TCP - The Credit Pros)
- Follow FCRA compliance patterns where applicable
- Include tests for data validation and security
- Test file should be complete and ready to run

Generate only the test code, no explanations:`;
  }

  /**
   * Call OpenAI API
   */
  async callOpenAI(prompt) {
    return new Promise((resolve, reject) => {
      const data = JSON.stringify({
        model: 'gpt-4',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        max_tokens: 2000,
        temperature: 0.3,
      });

      const options = {
        hostname: 'api.openai.com',
        path: '/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this.openaiApiKey}`,
          'Content-Length': data.length,
        },
      };

      const req = https.request(options, (res) => {
        let responseData = '';

        res.on('data', (chunk) => {
          responseData += chunk;
        });

        res.on('end', () => {
          try {
            const parsed = JSON.parse(responseData);

            if (parsed.error) {
              reject(new Error(parsed.error.message));
            } else if (parsed.choices && parsed.choices[0]) {
              resolve(parsed.choices[0].message.content);
            } else {
              reject(new Error('Unexpected API response format'));
            }
          } catch (error) {
            reject(new Error(`Failed to parse API response: ${error.message}`));
          }
        });
      });

      req.on('error', (error) => {
        reject(new Error(`API request failed: ${error.message}`));
      });

      req.write(data);
      req.end();
    });
  }

  /**
   * Process AI response and clean up generated code
   */
  processAIResponse(aiResponse, filePath, testType) {
    // Clean up the response - remove markdown formatting
    const testCode = aiResponse
      .replace(/```javascript|```js|```typescript|```ts|```php/g, '')
      .replace(/```/g, '')
      .trim();

    // Add header comment
    const fileName = path.basename(filePath);
    const header = `// AI-Generated ${testType} tests for ${fileName}
// Generated on: ${new Date().toISOString()}
// Generated by: OpenAI GPT-4 via AI-SDLC Framework

`;

    return header + testCode;
  }

  /**
   * Detect framework from source code
   */
  detectFramework(sourceCode) {
    if (sourceCode.includes('<?php')) return 'PHP/Laravel';
    if (
      sourceCode.includes('import React') ||
      sourceCode.includes('from "react"')
    )
      return 'React';
    if (
      sourceCode.includes('import { Component }') ||
      sourceCode.includes('extends Component')
    )
      return 'React';
    if (
      sourceCode.includes('export default') &&
      sourceCode.includes('function')
    )
      return 'JavaScript/Node.js';
    if (
      sourceCode.includes('interface ') ||
      sourceCode.includes(': string') ||
      sourceCode.includes(': number')
    )
      return 'TypeScript';
    return 'JavaScript/Node.js';
  }

  /**
   * Template fallback generation
   */
  generateTemplateTests(sourceCode, filePath, _testType) {
    const fileName = path.basename(filePath, path.extname(filePath));
    const fileExtension = path.extname(filePath);

    if (fileExtension === '.php') {
      return this.generatePHPTemplate(fileName, sourceCode);
    } else if (sourceCode.includes('React') || sourceCode.includes('jsx')) {
      return this.generateReactTemplate(fileName, sourceCode);
    } else {
      return this.generateJavaScriptTemplate(fileName, sourceCode);
    }
  }

  /**
   * Generate React test template
   */
  generateReactTemplate(componentName, _sourceCode) {
    return `// Template-generated React tests for ${componentName}
// Generated on: ${new Date().toISOString()}

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ${componentName} } from '../${componentName}';

describe('${componentName}', () => {
  const defaultProps = {
    // Add default props based on component needs
  };

  const renderComponent = (props = {}) => {
    return render(<${componentName} {...defaultProps} {...props} />);
  };

  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

  it('should render without crashing', () => {
    renderComponent();
    // Add assertions based on component structure
  });

  it('should handle user interactions', async () => {
    renderComponent();
    
    // Example interaction test
    // const button = screen.getByRole('button');
    // fireEvent.click(button);
    // await waitFor(() => {
    //   expect(screen.getByText('Expected Result')).toBeInTheDocument();
    // });
  });

  it('should handle props correctly', () => {
    const testProps = { testProp: 'test value' };
    renderComponent(testProps);
    
    // Add prop validation tests
  });

  it('should handle edge cases', () => {
    // Test edge cases like empty props, null values, etc.
  });

  it('should be accessible', () => {
    renderComponent();
    // Add accessibility tests
  });
});`;
  }

  /**
   * Generate JavaScript test template
   */
  generateJavaScriptTemplate(moduleName, sourceCode) {
    // Extract function names from source
    const functions = this.extractFunctions(sourceCode);

    return `// Template-generated JavaScript tests for ${moduleName}
// Generated on: ${new Date().toISOString()}

${functions.length > 0 ? `import { ${functions.join(', ')} } from '../${moduleName}';` : `const ${moduleName} = require('../${moduleName}');`}

describe('${moduleName}', () => {
  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

${functions
  .map(
    (func) => `
  describe('${func}', () => {
    it('should work with valid input', () => {
      // Test ${func} with valid parameters
      expect(typeof ${func}).toBe('function');
    });

    it('should handle edge cases', () => {
      // Test ${func} with edge cases
    });

    it('should handle errors gracefully', () => {
      // Test ${func} error handling
    });
  });`
  )
  .join('')}

  it('should export expected functions', () => {
    // Verify module exports
    ${functions.map((func) => `expect(typeof ${func}).toBe('function');`).join('\n    ')}
  });
});`;
  }

  /**
   * Generate PHP test template
   */
  generatePHPTemplate(className, _sourceCode) {
    return `<?php

// Template-generated PHP tests for ${className}
// Generated on: ${new Date().toISOString()}

namespace Tests\\Unit;

use Tests\\TestCase;
use App\\${className};
use Illuminate\\Foundation\\Testing\\RefreshDatabase;

class ${className}Test extends TestCase
{
    use RefreshDatabase;

    protected $${className.toLowerCase()};

    public function setUp(): void
    {
        parent::setUp();
        $this->${className.toLowerCase()} = new ${className}();
    }

    public function tearDown(): void
    {
        parent::tearDown();
    }

    /** @test */
    public function it_can_be_instantiated()
    {
        $this->assertInstanceOf(${className}::class, $this->${className.toLowerCase()});
    }

    /** @test */
    public function it_handles_valid_input()
    {
        // Test with valid input
        $this->assertTrue(true);
    }

    /** @test */
    public function it_handles_invalid_input()
    {
        // Test with invalid input
        $this->expectException(\\InvalidArgumentException::class);
        // Add test code here
    }

    /** @test */
    public function it_follows_fcra_compliance()
    {
        // Test FCRA compliance requirements
        $this->assertTrue(true);
    }
}`;
  }

  /**
   * Extract function names from JavaScript/TypeScript code
   */
  extractFunctions(sourceCode) {
    const functions = [];

    // Match function declarations
    const functionMatches = sourceCode.match(/function\s+(\w+)/g);
    if (functionMatches) {
      functions.push(
        ...functionMatches.map((match) => match.replace('function ', ''))
      );
    }

    // Match const/let function assignments
    const constMatches = sourceCode.match(
      /(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\(/g
    );
    if (constMatches) {
      functions.push(
        ...constMatches.map((match) =>
          match
            .replace(/(?:const|let|var)\s+/, '')
            .replace(/\s*=\s*(?:async\s+)?\(/, '')
        )
      );
    }

    // Match arrow functions
    const arrowMatches = sourceCode.match(
      /(?:const|let|var)\s+(\w+)\s*=\s*(?:async\s+)?\(.*?\)\s*=>/g
    );
    if (arrowMatches) {
      functions.push(
        ...arrowMatches.map((match) =>
          match
            .replace(/(?:const|let|var)\s+/, '')
            .replace(/\s*=\s*(?:async\s+)?\(.*?\)\s*=>/, '')
        )
      );
    }

    return [...new Set(functions)]; // Remove duplicates
  }

  /**
   * Main test generation function
   */
  async generateTestsForFile(filePath, testType = 'unit') {
    try {
      if (!fs.existsSync(filePath)) {
        throw new Error(`File not found: ${filePath}`);
      }

      const sourceCode = fs.readFileSync(filePath, 'utf8');
      console.log(`🤖 Generating ${testType} tests for ${filePath}...`);

      const testCode = await this.generateRealAITests(
        sourceCode,
        filePath,
        testType
      );

      // Generate test file path
      const testFilePath = this.getTestFilePath(filePath, testType);

      // Ensure test directory exists
      const testDir = path.dirname(testFilePath);
      if (!fs.existsSync(testDir)) {
        fs.mkdirSync(testDir, { recursive: true });
      }

      // Write test file
      fs.writeFileSync(testFilePath, testCode);

      console.log(
        `✅ Generated ${this.useTemplateMode ? 'template' : 'AI'} tests: ${testFilePath}`
      );

      return {
        status: 'success',
        sourceFile: filePath,
        testFile: testFilePath,
        testType,
        aiGenerated: !this.useTemplateMode,
      };
    } catch (error) {
      console.error(
        `❌ Failed to generate tests for ${filePath}:`,
        error.message
      );
      return {
        status: 'failed',
        error: error.message,
        sourceFile: filePath,
      };
    }
  }

  /**
   * Get test file path based on source file
   */
  getTestFilePath(sourceFilePath, testType) {
    const relativePath = path.relative(this.projectRoot, sourceFilePath);
    const parsedPath = path.parse(relativePath);

    let testDir = '__tests__';
    if (testType === 'integration') testDir = 'tests/integration';
    else if (testType === 'e2e') testDir = 'tests/e2e';

    const testFileName = `${parsedPath.name}.test${parsedPath.ext}`;
    return path.join(this.projectRoot, testDir, parsedPath.dir, testFileName);
  }
}

// CLI interface
async function main() {
  const generator = new RealAITestGenerator();
  const command = process.argv[2];
  const filePath = process.argv[3];
  const testType = process.argv[4] || 'unit';

  switch (command) {
    case 'generate': {
      if (!filePath) {
        console.error('❌ Please specify a file path');
        process.exit(1);
      }

      const result = await generator.generateTestsForFile(filePath, testType);

      if (result.status === 'success') {
        console.log('');
        console.log('🎉 Test generation completed successfully!');
        console.log(`📁 Test file: ${result.testFile}`);
        console.log(
          `🤖 AI Generated: ${result.aiGenerated ? 'Yes' : 'No (Template)'}`
        );
      } else {
        console.error('💥 Test generation failed');
        process.exit(1);
      }
      break;
    }

    default:
      console.log('Real AI Test Generator for AI-SDLC Framework');
      console.log('');
      console.log('Usage:');
      console.log(
        '  real-ai-test-generator.js generate <file-path> [test-type]'
      );
      console.log('');
      console.log('Arguments:');
      console.log('  file-path   Path to source file to generate tests for');
      console.log(
        '  test-type   Type of tests: unit, integration, e2e (default: unit)'
      );
      console.log('');
      console.log('Examples:');
      console.log(
        '  node real-ai-test-generator.js generate src/utils/creditScore.js unit'
      );
      console.log(
        '  node real-ai-test-generator.js generate src/components/CreditReport.jsx integration'
      );
      console.log('');
      console.log('Environment Variables:');
      console.log('  OPENAI_API_KEY - Required for AI-powered generation');
      console.log('  Without API key, falls back to template generation');
      break;
  }
}

// Export for use as module
module.exports = RealAITestGenerator;

// Run CLI if called directly
if (require.main === module) {
  main().catch((error) => {
    console.error('❌ Error:', error.message);
    process.exit(1);
  });
}
